" -----------------------------------------------------------------------------
" VIM Plugins
" https://github.com/junegunn/vim-plug/wiki/tips#automatic-installation
" -----------------------------------------------------------------------------
let data_dir = has('nvim') ? stdpath('data') . '/site' : '~/.vim'
if empty(glob(data_dir . '/autoload/plug.vim'))
    silent execute '!curl -fLo '.data_dir.'/autoload/plug.vim --create-dirs  https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim'
    autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
endif

" Start vim-plug code
call plug#begin('~/.vim/plugged')
    Plug 'tpope/vim-fugitive'           " git wrapper for vim
    Plug 'tpope/vim-commentary'           " Code commenting
    Plug 'sheerun/vim-polyglot'         " Syntax coloring
    Plug 'airblade/vim-gitgutter'
    Plug 'vim-airline/vim-airline'      " status/tab line
    Plug 'vim-airline/vim-airline-themes'
    Plug 'https://github.com/Mangeshrex/uwu.vim.git'
call plug#end()

" let g:airline#extensions#tabline#enabled = 1
" let g:airline#extensions#tabline#fnamewod = ':t'

filetype plugin on " load settings by filetype from .vim/ftplugin
source ~/.files/vim/snippets/snippets.vim " custom snippets
source ~/.files/vim/netrw_settings.vim

" -----------------------------------------------------------------------------
" VIM/Style settings
" -----------------------------------------------------------------------------
set title          " change the terminal title
set visualbell      " turn off annoying bell noise
syntax enable       " Enable syntax highlighting
set background=dark
colorscheme uwu     " plugin colorscheme
set nocompatible   " Don't emulate vi
set mouse=a        " Enable mouse
set hlsearch       " Highlight search terms
set incsearch      " Highlight incrementally while searching
set number         " Show line number on cursor
set relativenumber " Show relative line numbers
set colorcolumn=80 " Draws column at 80 characters
set nowrap         " Lines don't wrap
set expandtab      " Tabs become spaces
set shiftwidth=4   " Shifts only shift three spaces
set softtabstop=0  " If non-zero, makes the <TAB> & <BS> keys feel like tabs
set tabstop=4      " Tabs stop at three characters
set backspace=indent,eol,start " Backspace over everything in insert mode
" set autoindent     " Auto indent
" set copyindent     " Use last line indentation, affects <BR> key
" set smarttab       " Insert new line tabs based on shiftwidth not tabstop
set list           " List will mark any characters specified by `listchars`
set listchars=tab:\ \ ,trail:·,extends:▶
set wildignore=*.swp,*.bak,*.pyc,*.class,*.o " Don't auto-complete these files
set path+=**       " fuzzy finder for file-related tasks
set wildmenu       " display matching files when tab completing
hi vertsplit guifg=bg guibg=CYAN term=NONE
autocmd BufWritePre * :%s/\s\+$//e " remove trailing whitespace on save
" -----------------------------------------------------------------------------
" VIM tabs
" -----------------------------------------------------------------------------
set showtabline=2  " always display the tab bar
" TODO: Figure out how to get tabs to only display file and not netrw
set guitablabel='\[%N\]\ %t\ %M'





" -----------------------------------------------------------------------------
" Mappings
" -----------------------------------------------------------------------------

" source .vimrc
map <Leader>sv :source $MYVIMRC<CR>

" Open netrw sidebar
nnoremap <Leader>e :24Lexplore<CR>

" Open Git explorer
nnoremap <Leader>g :Git<CR>

" Tab to cycle tabs
nnoremap <Tab> :tabn<CR>
nnoremap <S-Tab> :tabp<CR>

" Shift+Tab to cycle tabs

" Insert Mode escape
inoremap jk <Esc>
inoremap kj <Esc>

" Keep cursor at the bottom of the visual selection after you yank it.
vmap y ygv<Esc>

" Prevent selecting and pasting from overwriting what you originally copied.
xnoremap p pgvy

" Prevent x from overriding copy
noremap x "_x
noremap X "_X

" Escape to normal mode after inserting a line
noremap o o<Esc>
noremap O O<Esc>

" Press * to search for the term under the cursor or a visual selection and
" then press a key below to replace all instances of it in the current file.
nnoremap <Leader>r :%s///gc<Left><Left><Left>

" Clear search highlights.
map <Leader>* :let @/=''<CR>

" open terminal
map <Leader>t :belowright terminal ++rows=10<CR>

" -----------------------------------------------------------------------------
" autocommands
" -----------------------------------------------------------------------------

" Open markdown files with Chrome.
" autocmd BufEnter *.md exe 'noremap <F5> :! /Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome %:p<CR>'

" Update buffer if focus is changed outside of vim
au FocusGained,BufEnter * :checktime

" Auto-resize splits when Vim is resized
autocmd VimResized * wincmd =

" Adjust the column color of active pane
" TODO: Adjust more settings to distinguish active pane
function! OnWinEnter()
    setlocal cursorline

    if exists('w:initial_cc')
        let &colorcolumn = w:initial_cc
    endif
endfunction

function! OnWinLeave()
    setlocal nocursorline

    if !exists('w:initial_cc')
        let w:initial_cc=&colorcolumn
    endif
        let &colorcolumn = 0
endfunction

augroup ActiveWindowStyling
    autocmd!
    autocmd WinEnter,BufWinEnter * call OnWinEnter()
    autocmd WinLeave * call OnWinLeave()
augroup END

" Blink on highlight during search
nnoremap <silent> n n:call HLNext(0.2)<cr>
nnoremap <silent> N N:call HLNext(0.2)<cr>
function! HLNext (blinktime)
    highlight WhiteOnRed ctermfg=white ctermbg=red
    let [bufnum, lnum, col, off] = getpos('.')
    let matchlen = strlen(matchstr(strpart(getline('.'),col-1),@/))
    let target_pat = '\c\%#'.@/
    let blinks = 2

    for n in range(1,blinks)
        let red = matchadd('WhiteOnRed', target_pat, 101)
        redraw
        exec 'sleep ' . float2nr(a:blinktime / (2*blinks) * 1000) . 'm'
        call matchdelete(red)
        redraw
        exec 'sleep ' . float2nr(a:blinktime / (2*blinks) * 1000) . 'm'
    endfor
endfunction

" Toggle quickfix window.
function! QuickFix_toggle()
    for i in range(1, winnr('$'))
        let bnum = winbufnr(i)
        if getbufvar(bnum, '&buftype') == 'quickfix'
            cclose
            return
        endif
    endfor
    copen
endfunction
nnoremap <silent> <Leader>c :call QuickFix_toggle()<CR>
